<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>STM32 Peripheral Driver: I2C_Exported_Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>I2C_Exported_Functions<br/>
<small>
[<a class="el" href="group___i2_c.html">I2C</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga2ee214364603059ad5d9089f749f5bfd">I2C_DeInit</a> (I2C_TypeDef *I2Cx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deinitializes the I2Cx peripheral registers to their default reset values.  <a href="#ga2ee214364603059ad5d9089f749f5bfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#gaac29465bca70fbc91c2f922ab67bb88e">I2C_Init</a> (I2C_TypeDef *I2Cx, <a class="el" href="struct_i2_c___init_type_def.html">I2C_InitTypeDef</a> *I2C_InitStruct)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the I2Cx peripheral according to the specified parameters in the I2C_InitStruct.  <a href="#gaac29465bca70fbc91c2f922ab67bb88e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga08582aca6d7d7910cd5cbff0d9def350">I2C_StructInit</a> (<a class="el" href="struct_i2_c___init_type_def.html">I2C_InitTypeDef</a> *I2C_InitStruct)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills each I2C_InitStruct member with its default value.  <a href="#ga08582aca6d7d7910cd5cbff0d9def350"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga7e1323c9133c2cb424dfb5b10b7d2f0b">I2C_Cmd</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the specified I2C peripheral.  <a href="#ga7e1323c9133c2cb424dfb5b10b7d2f0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga38502ce11e5ec923e0f6476aaa35b45c">I2C_DMACmd</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the specified I2C DMA requests.  <a href="#ga38502ce11e5ec923e0f6476aaa35b45c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#gab2e994c5681eb6ec7c26a03ffe1de060">I2C_DMALastTransferCmd</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies if the next DMA transfer will be the last one.  <a href="#gab2e994c5681eb6ec7c26a03ffe1de060"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga36c522b471588be9779c878222ccb20f">I2C_GenerateSTART</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates I2Cx communication START condition.  <a href="#ga36c522b471588be9779c878222ccb20f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga5c92cb573ca0ae58cc465e5400246561">I2C_GenerateSTOP</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates I2Cx communication STOP condition.  <a href="#ga5c92cb573ca0ae58cc465e5400246561"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga7bb44e894d68a7991f564c43fb187486">I2C_AcknowledgeConfig</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the specified I2C acknowledge feature.  <a href="#ga7bb44e894d68a7991f564c43fb187486"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga7be2cc634a613c8e3539137e897a22df">I2C_OwnAddress2Config</a> (I2C_TypeDef *I2Cx, uint8_t Address)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures the specified I2C own address2.  <a href="#ga7be2cc634a613c8e3539137e897a22df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga02145a333a56e79557d6ef4ea03fc313">I2C_DualAddressCmd</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the specified I2C dual addressing mode.  <a href="#ga02145a333a56e79557d6ef4ea03fc313"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga65c740fc8d7b3b9f15cc432d8699d471">I2C_GeneralCallCmd</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the specified I2C general call feature.  <a href="#ga65c740fc8d7b3b9f15cc432d8699d471"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga58fed146a06cb81d2940604e460de047">I2C_ITConfig</a> (I2C_TypeDef *I2Cx, uint16_t I2C_IT, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the specified I2C interrupts.  <a href="#ga58fed146a06cb81d2940604e460de047"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga7bd9e70b8eafde0dd5eb42b0d95fe1a9">I2C_SendData</a> (I2C_TypeDef *I2Cx, uint8_t Data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a data byte through the I2Cx peripheral.  <a href="#ga7bd9e70b8eafde0dd5eb42b0d95fe1a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#gaeaaa4b6f77f50eb57465148c55d27fb2">I2C_ReceiveData</a> (I2C_TypeDef *I2Cx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the most recent received data by the I2Cx peripheral.  <a href="#gaeaaa4b6f77f50eb57465148c55d27fb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga009fc2a5b2313c36da39ece39a1156a6">I2C_Send7bitAddress</a> (I2C_TypeDef *I2Cx, uint8_t Address, uint8_t I2C_Direction)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transmits the address byte to select the slave device.  <a href="#ga009fc2a5b2313c36da39ece39a1156a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga8021dc796d15f997356b0583d6346805">I2C_ReadRegister</a> (I2C_TypeDef *I2Cx, uint8_t I2C_Register)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the specified I2C register and returns its value.  <a href="#ga8021dc796d15f997356b0583d6346805"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga1289c908aeb882443aba323b459c638b">I2C_SoftwareResetCmd</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the specified I2C software reset.  <a href="#ga1289c908aeb882443aba323b459c638b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga75a810776d9710d2f6d9c5d9e93241c6">I2C_SMBusAlertConfig</a> (I2C_TypeDef *I2Cx, uint16_t I2C_SMBusAlert)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drives the SMBusAlert pin high or low for the specified I2C.  <a href="#ga75a810776d9710d2f6d9c5d9e93241c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#gaa27d1440290fe601e730b6980999afe3">I2C_TransmitPEC</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the specified I2C PEC transfer.  <a href="#gaa27d1440290fe601e730b6980999afe3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga5d0f939bdd45542502827bf408f24161">I2C_PECPositionConfig</a> (I2C_TypeDef *I2Cx, uint16_t I2C_PECPosition)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Selects the specified I2C PEC position.  <a href="#ga5d0f939bdd45542502827bf408f24161"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#gae86801251359226c35745e0a258388b0">I2C_CalculatePEC</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the PEC value calculation of the transfered bytes.  <a href="#gae86801251359226c35745e0a258388b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga7bf75e7c27c0e1d73e70fc0e1c7cd1dd">I2C_GetPEC</a> (I2C_TypeDef *I2Cx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the PEC value for the specified I2C.  <a href="#ga7bf75e7c27c0e1d73e70fc0e1c7cd1dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga66d86742bf1be58b17ef8779ffc79d02">I2C_ARPCmd</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the specified I2C ARP.  <a href="#ga66d86742bf1be58b17ef8779ffc79d02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga7459feb3b1dfcd3e4f6574002ca7d3bd">I2C_StretchClockCmd</a> (I2C_TypeDef *I2Cx, FunctionalState NewState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the specified I2C Clock stretching.  <a href="#ga7459feb3b1dfcd3e4f6574002ca7d3bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#gaa570f76bc34e5b0531b29b1a90af1275">I2C_FastModeDutyCycleConfig</a> (I2C_TypeDef *I2Cx, uint16_t I2C_DutyCycle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Selects the specified I2C fast mode duty cycle.  <a href="#gaa570f76bc34e5b0531b29b1a90af1275"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ErrorStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga2d5701342f9d4c1f09bf9d3cdcacc326">I2C_CheckEvent</a> (I2C_TypeDef *I2Cx, uint32_t I2C_EVENT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">I2C State Monitoring Functions.  <a href="#ga2d5701342f9d4c1f09bf9d3cdcacc326"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga29237aea9b5a3ead33167e1d027e9f1a">I2C_GetLastEvent</a> (I2C_TypeDef *I2Cx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last I2Cx Event.  <a href="#ga29237aea9b5a3ead33167e1d027e9f1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FlagStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga15c95d0ed124f029621a2061b1677ee7">I2C_GetFlagStatus</a> (I2C_TypeDef *I2Cx, uint32_t I2C_FLAG)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether the specified I2C flag is set or not.  <a href="#ga15c95d0ed124f029621a2061b1677ee7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga9d4f8fe9f7232696114b5578b1223963">I2C_ClearFlag</a> (I2C_TypeDef *I2Cx, uint32_t I2C_FLAG)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the I2Cx's pending flags.  <a href="#ga9d4f8fe9f7232696114b5578b1223963"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ITStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga447771fbbd94a56f3570b9f430a069ba">I2C_GetITStatus</a> (I2C_TypeDef *I2Cx, uint32_t I2C_IT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether the specified I2C interrupt has occurred or not.  <a href="#ga447771fbbd94a56f3570b9f430a069ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___exported___functions.html#ga110dda440fa200b5f77349df19b3e6bb">I2C_ClearITPendingBit</a> (I2C_TypeDef *I2Cx, uint32_t I2C_IT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the I2Cx’s interrupt pending bits.  <a href="#ga110dda440fa200b5f77349df19b3e6bb"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga7bb44e894d68a7991f564c43fb187486"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_AcknowledgeConfig" ref="ga7bb44e894d68a7991f564c43fb187486" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_AcknowledgeConfig </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the specified I2C acknowledge feature. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2C Acknowledgement. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None.</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga66d86742bf1be58b17ef8779ffc79d02"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_ARPCmd" ref="ga66d86742bf1be58b17ef8779ffc79d02" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_ARPCmd </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the specified I2C ARP. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2Cx ARP. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae86801251359226c35745e0a258388b0"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_CalculatePEC" ref="gae86801251359226c35745e0a258388b0" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_CalculatePEC </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the PEC value calculation of the transfered bytes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2Cx PEC value calculation. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2d5701342f9d4c1f09bf9d3cdcacc326"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_CheckEvent" ref="ga2d5701342f9d4c1f09bf9d3cdcacc326" args="(I2C_TypeDef *I2Cx, uint32_t I2C_EVENT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ErrorStatus I2C_CheckEvent </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>I2C_EVENT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>I2C State Monitoring Functions. </p>
<p>This I2C driver provides three different ways for I2C state monitoring depending on the application requirements and constraints:</p>
<p>1) Basic state monitoring: Using <a class="el" href="group___i2_c___exported___functions.html#ga2d5701342f9d4c1f09bf9d3cdcacc326" title="I2C State Monitoring Functions.">I2C_CheckEvent()</a> function: It compares the status registers (SR1 and SR2) content to a given event (can be the combination of one or more flags). It returns SUCCESS if the current status includes the given flags and returns ERROR if one or more flags are missing in the current status.</p>
<ul>
<li>When to use:<ul>
<li>This function is suitable for most applications as well as for startup activity since the events are fully described in the product reference manual (RM0008).</li>
<li>It is also suitable for users who need to define their own events.</li>
</ul>
</li>
<li>Limitations:<ul>
<li>If an error occurs (ie. error flags are set besides to the monitored flags), the <a class="el" href="group___i2_c___exported___functions.html#ga2d5701342f9d4c1f09bf9d3cdcacc326" title="I2C State Monitoring Functions.">I2C_CheckEvent()</a> function may return SUCCESS despite the communication hold or corrupted real state. In this case, it is advised to use error interrupts to monitor the error events and handle them in the interrupt IRQ handler.</li>
</ul>
</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>For error management, it is advised to use the following functions:<ul>
<li><a class="el" href="group___i2_c___exported___functions.html#ga58fed146a06cb81d2940604e460de047" title="Enables or disables the specified I2C interrupts.">I2C_ITConfig()</a> to configure and enable the error interrupts (I2C_IT_ERR).</li>
<li>I2Cx_ER_IRQHandler() which is called when the error interurpt occurs. Where x is the peripheral instance (I2C1, I2C2 ...)</li>
<li><a class="el" href="group___i2_c___exported___functions.html#ga15c95d0ed124f029621a2061b1677ee7" title="Checks whether the specified I2C flag is set or not.">I2C_GetFlagStatus()</a> or <a class="el" href="group___i2_c___exported___functions.html#ga447771fbbd94a56f3570b9f430a069ba" title="Checks whether the specified I2C interrupt has occurred or not.">I2C_GetITStatus()</a> to be called into I2Cx_ER_IRQHandler() in order to determine which error occured.</li>
<li><a class="el" href="group___i2_c___exported___functions.html#ga9d4f8fe9f7232696114b5578b1223963" title="Clears the I2Cx&#39;s pending flags.">I2C_ClearFlag()</a> or <a class="el" href="group___i2_c___exported___functions.html#ga110dda440fa200b5f77349df19b3e6bb" title="Clears the I2Cx’s interrupt pending bits.">I2C_ClearITPendingBit()</a> and/or <a class="el" href="group___i2_c___exported___functions.html#ga1289c908aeb882443aba323b459c638b" title="Enables or disables the specified I2C software reset.">I2C_SoftwareResetCmd()</a> and/or I2C_GenerateStop() in order to clear the error flag and source, and return to correct communication status.</li>
</ul>
</dd></dl>
<p>2) Advanced state monitoring: Using the function <a class="el" href="group___i2_c___exported___functions.html#ga29237aea9b5a3ead33167e1d027e9f1a" title="Returns the last I2Cx Event.">I2C_GetLastEvent()</a> which returns the image of both status registers in a single word (uint32_t) (Status Register 2 value is shifted left by 16 bits and concatenated to Status Register 1).</p>
<ul>
<li>When to use:<ul>
<li>This function is suitable for the same applications above but it allows to overcome the limitations of <a class="el" href="group___i2_c___exported___functions.html#ga15c95d0ed124f029621a2061b1677ee7" title="Checks whether the specified I2C flag is set or not.">I2C_GetFlagStatus()</a> function (see below). The returned value could be compared to events already defined in the library (<a class="el" href="stm32f10x__i2c_8h.html" title="This file contains all the functions prototypes for the I2C firmware library.">stm32f10x_i2c.h</a>) or to custom values defined by user.</li>
<li>This function is suitable when multiple flags are monitored at the same time.</li>
<li>At the opposite of <a class="el" href="group___i2_c___exported___functions.html#ga2d5701342f9d4c1f09bf9d3cdcacc326" title="I2C State Monitoring Functions.">I2C_CheckEvent()</a> function, this function allows user to choose when an event is accepted (when all events flags are set and no other flags are set or just when the needed flags are set like <a class="el" href="group___i2_c___exported___functions.html#ga2d5701342f9d4c1f09bf9d3cdcacc326" title="I2C State Monitoring Functions.">I2C_CheckEvent()</a> function).</li>
</ul>
</li>
<li>Limitations:<ul>
<li>User may need to define his own events.</li>
<li>Same remark concerning the error management is applicable for this function if user decides to check only regular communication flags (and ignores error flags).</li>
</ul>
</li>
</ul>
<p>3) Flag-based state monitoring: Using the function <a class="el" href="group___i2_c___exported___functions.html#ga15c95d0ed124f029621a2061b1677ee7" title="Checks whether the specified I2C flag is set or not.">I2C_GetFlagStatus()</a> which simply returns the status of one single flag (ie. I2C_FLAG_RXNE ...).</p>
<ul>
<li>When to use:<ul>
<li>This function could be used for specific applications or in debug phase.</li>
<li>It is suitable when only one flag checking is needed (most I2C events are monitored through multiple flags).</li>
</ul>
</li>
<li>Limitations:<ul>
<li>When calling this function, the Status register is accessed. Some flags are cleared when the status register is accessed. So checking the status of one Flag, may clear other ones.</li>
<li>Function may need to be called twice or more in order to monitor one single event.</li>
</ul>
</li>
</ul>
<p>1) Basic state monitoring</p>
<p>This I2C driver provides three different ways for I2C state monitoring depending on the application requirements and constraints:</p>
<p>1) Basic state monitoring: Using <a class="el" href="group___i2_c___exported___functions.html#ga2d5701342f9d4c1f09bf9d3cdcacc326" title="I2C State Monitoring Functions.">I2C_CheckEvent()</a> function: It compares the status registers (SR1 and SR2) content to a given event (can be the combination of one or more flags). It returns SUCCESS if the current status includes the given flags and returns ERROR if one or more flags are missing in the current status.</p>
<ul>
<li>When to use:<ul>
<li>This function is suitable for most applciations as well as for startup activity since the events are fully described in the product reference manual (RM0008).</li>
<li>It is also suitable for users who need to define their own events.</li>
</ul>
</li>
<li>Limitations:<ul>
<li>If an error occurs (ie. error flags are set besides to the monitored flags), the <a class="el" href="group___i2_c___exported___functions.html#ga2d5701342f9d4c1f09bf9d3cdcacc326" title="I2C State Monitoring Functions.">I2C_CheckEvent()</a> function may return SUCCESS despite the communication hold or corrupted real state. In this case, it is advised to use error interrupts to monitor the error events and handle them in the interrupt IRQ handler.</li>
</ul>
</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>For error management, it is advised to use the following functions:<ul>
<li><a class="el" href="group___i2_c___exported___functions.html#ga58fed146a06cb81d2940604e460de047" title="Enables or disables the specified I2C interrupts.">I2C_ITConfig()</a> to configure and enable the error interrupts (I2C_IT_ERR).</li>
<li>I2Cx_ER_IRQHandler() which is called when the error interurpt occurs. Where x is the peripheral instance (I2C1, I2C2 ...)</li>
<li><a class="el" href="group___i2_c___exported___functions.html#ga15c95d0ed124f029621a2061b1677ee7" title="Checks whether the specified I2C flag is set or not.">I2C_GetFlagStatus()</a> or <a class="el" href="group___i2_c___exported___functions.html#ga447771fbbd94a56f3570b9f430a069ba" title="Checks whether the specified I2C interrupt has occurred or not.">I2C_GetITStatus()</a> to be called into I2Cx_ER_IRQHandler() in order to determine which error occured.</li>
<li><a class="el" href="group___i2_c___exported___functions.html#ga9d4f8fe9f7232696114b5578b1223963" title="Clears the I2Cx&#39;s pending flags.">I2C_ClearFlag()</a> or <a class="el" href="group___i2_c___exported___functions.html#ga110dda440fa200b5f77349df19b3e6bb" title="Clears the I2Cx’s interrupt pending bits.">I2C_ClearITPendingBit()</a> and/or <a class="el" href="group___i2_c___exported___functions.html#ga1289c908aeb882443aba323b459c638b" title="Enables or disables the specified I2C software reset.">I2C_SoftwareResetCmd()</a> and/or I2C_GenerateStop() in order to clear the error flag and source, and return to correct communication status.</li>
</ul>
</dd></dl>
<p>2) Advanced state monitoring: Using the function <a class="el" href="group___i2_c___exported___functions.html#ga29237aea9b5a3ead33167e1d027e9f1a" title="Returns the last I2Cx Event.">I2C_GetLastEvent()</a> which returns the image of both status registers in a single word (uint32_t) (Status Register 2 value is shifted left by 16 bits and concatenated to Status Register 1).</p>
<ul>
<li>When to use:<ul>
<li>This function is suitable for the same applications above but it allows to overcome the mentionned limitation of <a class="el" href="group___i2_c___exported___functions.html#ga15c95d0ed124f029621a2061b1677ee7" title="Checks whether the specified I2C flag is set or not.">I2C_GetFlagStatus()</a> function. The returned value could be compared to events already defined in the library (<a class="el" href="stm32f10x__i2c_8h.html" title="This file contains all the functions prototypes for the I2C firmware library.">stm32f10x_i2c.h</a>) or to custom values defiend by user.</li>
<li>This function is suitable when multiple flags are monitored at the same time.</li>
<li>At the opposite of <a class="el" href="group___i2_c___exported___functions.html#ga2d5701342f9d4c1f09bf9d3cdcacc326" title="I2C State Monitoring Functions.">I2C_CheckEvent()</a> function, this function allows user to choose when an event is accepted (when all events flags are set and no other flags are set or just when the needed flags are set like <a class="el" href="group___i2_c___exported___functions.html#ga2d5701342f9d4c1f09bf9d3cdcacc326" title="I2C State Monitoring Functions.">I2C_CheckEvent()</a> function).</li>
</ul>
</li>
<li>Limitations:<ul>
<li>User may need to define his own events.</li>
<li>Same remark concerning the error management is applicable for this function if user decides to check only regular communication flags (and ignores error flags).</li>
</ul>
</li>
</ul>
<p>3) Flag-based state monitoring: Using the function <a class="el" href="group___i2_c___exported___functions.html#ga15c95d0ed124f029621a2061b1677ee7" title="Checks whether the specified I2C flag is set or not.">I2C_GetFlagStatus()</a> which simply returns the status of one single flag (ie. I2C_FLAG_RXNE ...).</p>
<ul>
<li>When to use:<ul>
<li>This function could be used for specific applications or in debug phase.</li>
<li>It is suitable when only one flag checking is needed (most I2C events are monitored through multiple flags).</li>
</ul>
</li>
<li>Limitations:<ul>
<li>When calling this function, the Status register is accessed. Some flags are cleared when the status register is accessed. So checking the status of one Flag, may clear other ones.</li>
<li>Function may need to be called twice or more in order to monitor one single event.</li>
</ul>
</li>
</ul>
<p>For detailed description of Events, please refer to section I2C_Events in <a class="el" href="stm32f10x__i2c_8h.html" title="This file contains all the functions prototypes for the I2C firmware library.">stm32f10x_i2c.h</a> file.</p>
<p>1) Basic state monitoring Checks whether the last I2Cx Event is equal to the one passed as parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I2C_EVENT,:</em>&nbsp;</td><td>specifies the event to be checked. This parameter can be one of the following values: </p>
<ul>
<li>I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED : EV1 </li>
<li>I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED : EV1 </li>
<li>I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED : EV1 </li>
<li>I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED : EV1 </li>
<li>I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED : EV1 </li>
<li>I2C_EVENT_SLAVE_BYTE_RECEIVED : EV2 </li>
<li>(I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF) : EV2 </li>
<li>(I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL) : EV2 </li>
<li>I2C_EVENT_SLAVE_BYTE_TRANSMITTED : EV3 </li>
<li>(I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF) : EV3 </li>
<li>(I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3 </li>
<li>I2C_EVENT_SLAVE_ACK_FAILURE : EV3_2 </li>
<li>I2C_EVENT_SLAVE_STOP_DETECTED : EV4 </li>
<li>I2C_EVENT_MASTER_MODE_SELECT : EV5 </li>
<li>I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED : EV6 </li>
<li>I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED : EV6 </li>
<li>I2C_EVENT_MASTER_BYTE_RECEIVED : EV7 </li>
<li>I2C_EVENT_MASTER_BYTE_TRANSMITTING : EV8 </li>
<li>I2C_EVENT_MASTER_BYTE_TRANSMITTED : EV8_2 </li>
<li>I2C_EVENT_MASTER_MODE_ADDRESS10 : EV9</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>: For detailed description of Events, please refer to section I2C_Events in <a class="el" href="stm32f10x__i2c_8h.html" title="This file contains all the functions prototypes for the I2C firmware library.">stm32f10x_i2c.h</a> file.</dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>An</em>&nbsp;</td><td>ErrorStatus enumuration value:</p>
<ul>
<li>SUCCESS: Last event is equal to the I2C_EVENT</li>
<li>ERROR: Last event is different from the I2C_EVENT </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9d4f8fe9f7232696114b5578b1223963"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_ClearFlag" ref="ga9d4f8fe9f7232696114b5578b1223963" args="(I2C_TypeDef *I2Cx, uint32_t I2C_FLAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_ClearFlag </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>I2C_FLAG</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the I2Cx's pending flags. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I2C_FLAG,:</em>&nbsp;</td><td>specifies the flag to clear. This parameter can be any combination of the following values: </p>
<ul>
<li>I2C_FLAG_SMBALERT: SMBus Alert flag </li>
<li>I2C_FLAG_TIMEOUT: Timeout or Tlow error flag </li>
<li>I2C_FLAG_PECERR: PEC error in reception flag </li>
<li>I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode) </li>
<li>I2C_FLAG_AF: Acknowledge failure flag </li>
<li>I2C_FLAG_ARLO: Arbitration lost flag (Master mode) </li>
<li>I2C_FLAG_BERR: Bus error flag</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd><ul>
<li>STOPF (STOP detection) is cleared by software sequence: a read operation to I2C_SR1 register (<a class="el" href="group___i2_c___exported___functions.html#ga15c95d0ed124f029621a2061b1677ee7" title="Checks whether the specified I2C flag is set or not.">I2C_GetFlagStatus()</a>) followed by a write operation to I2C_CR1 register (<a class="el" href="group___i2_c___exported___functions.html#ga7e1323c9133c2cb424dfb5b10b7d2f0b" title="Enables or disables the specified I2C peripheral.">I2C_Cmd()</a> to re-enable the I2C peripheral).</li>
<li>ADD10 (10-bit header sent) is cleared by software sequence: a read operation to I2C_SR1 (<a class="el" href="group___i2_c___exported___functions.html#ga15c95d0ed124f029621a2061b1677ee7" title="Checks whether the specified I2C flag is set or not.">I2C_GetFlagStatus()</a>) followed by writing the second byte of the address in DR register.</li>
<li>BTF (Byte Transfer Finished) is cleared by software sequence: a read operation to I2C_SR1 register (<a class="el" href="group___i2_c___exported___functions.html#ga15c95d0ed124f029621a2061b1677ee7" title="Checks whether the specified I2C flag is set or not.">I2C_GetFlagStatus()</a>) followed by a read/write to I2C_DR register (<a class="el" href="group___i2_c___exported___functions.html#ga7bd9e70b8eafde0dd5eb42b0d95fe1a9" title="Sends a data byte through the I2Cx peripheral.">I2C_SendData()</a>).</li>
<li>ADDR (Address sent) is cleared by software sequence: a read operation to I2C_SR1 register (<a class="el" href="group___i2_c___exported___functions.html#ga15c95d0ed124f029621a2061b1677ee7" title="Checks whether the specified I2C flag is set or not.">I2C_GetFlagStatus()</a>) followed by a read operation to I2C_SR2 register ((void)(I2Cx-&gt;SR2)).</li>
<li>SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1 register (<a class="el" href="group___i2_c___exported___functions.html#ga15c95d0ed124f029621a2061b1677ee7" title="Checks whether the specified I2C flag is set or not.">I2C_GetFlagStatus()</a>) followed by a write operation to I2C_DR register (<a class="el" href="group___i2_c___exported___functions.html#ga7bd9e70b8eafde0dd5eb42b0d95fe1a9" title="Sends a data byte through the I2Cx peripheral.">I2C_SendData()</a>). </li>
</ul>
</dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga110dda440fa200b5f77349df19b3e6bb"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_ClearITPendingBit" ref="ga110dda440fa200b5f77349df19b3e6bb" args="(I2C_TypeDef *I2Cx, uint32_t I2C_IT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_ClearITPendingBit </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>I2C_IT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the I2Cx’s interrupt pending bits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I2C_IT,:</em>&nbsp;</td><td>specifies the interrupt pending bit to clear. This parameter can be any combination of the following values: </p>
<ul>
<li>I2C_IT_SMBALERT: SMBus Alert interrupt </li>
<li>I2C_IT_TIMEOUT: Timeout or Tlow error interrupt </li>
<li>I2C_IT_PECERR: PEC error in reception interrupt </li>
<li>I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode) </li>
<li>I2C_IT_AF: Acknowledge failure interrupt </li>
<li>I2C_IT_ARLO: Arbitration lost interrupt (Master mode) </li>
<li>I2C_IT_BERR: Bus error interrupt</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd><ul>
<li>STOPF (STOP detection) is cleared by software sequence: a read operation to I2C_SR1 register (<a class="el" href="group___i2_c___exported___functions.html#ga447771fbbd94a56f3570b9f430a069ba" title="Checks whether the specified I2C interrupt has occurred or not.">I2C_GetITStatus()</a>) followed by a write operation to I2C_CR1 register (<a class="el" href="group___i2_c___exported___functions.html#ga7e1323c9133c2cb424dfb5b10b7d2f0b" title="Enables or disables the specified I2C peripheral.">I2C_Cmd()</a> to re-enable the I2C peripheral).</li>
<li>ADD10 (10-bit header sent) is cleared by software sequence: a read operation to I2C_SR1 (<a class="el" href="group___i2_c___exported___functions.html#ga447771fbbd94a56f3570b9f430a069ba" title="Checks whether the specified I2C interrupt has occurred or not.">I2C_GetITStatus()</a>) followed by writing the second byte of the address in I2C_DR register.</li>
<li>BTF (Byte Transfer Finished) is cleared by software sequence: a read operation to I2C_SR1 register (<a class="el" href="group___i2_c___exported___functions.html#ga447771fbbd94a56f3570b9f430a069ba" title="Checks whether the specified I2C interrupt has occurred or not.">I2C_GetITStatus()</a>) followed by a read/write to I2C_DR register (<a class="el" href="group___i2_c___exported___functions.html#ga7bd9e70b8eafde0dd5eb42b0d95fe1a9" title="Sends a data byte through the I2Cx peripheral.">I2C_SendData()</a>).</li>
<li>ADDR (Address sent) is cleared by software sequence: a read operation to I2C_SR1 register (<a class="el" href="group___i2_c___exported___functions.html#ga447771fbbd94a56f3570b9f430a069ba" title="Checks whether the specified I2C interrupt has occurred or not.">I2C_GetITStatus()</a>) followed by a read operation to I2C_SR2 register ((void)(I2Cx-&gt;SR2)).</li>
<li>SB (Start Bit) is cleared by software sequence: a read operation to I2C_SR1 register (<a class="el" href="group___i2_c___exported___functions.html#ga447771fbbd94a56f3570b9f430a069ba" title="Checks whether the specified I2C interrupt has occurred or not.">I2C_GetITStatus()</a>) followed by a write operation to I2C_DR register (<a class="el" href="group___i2_c___exported___functions.html#ga7bd9e70b8eafde0dd5eb42b0d95fe1a9" title="Sends a data byte through the I2Cx peripheral.">I2C_SendData()</a>). </li>
</ul>
</dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7e1323c9133c2cb424dfb5b10b7d2f0b"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_Cmd" ref="ga7e1323c9133c2cb424dfb5b10b7d2f0b" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Cmd </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the specified I2C peripheral. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2Cx peripheral. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2ee214364603059ad5d9089f749f5bfd"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_DeInit" ref="ga2ee214364603059ad5d9089f749f5bfd" args="(I2C_TypeDef *I2Cx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_DeInit </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deinitializes the I2Cx peripheral registers to their default reset values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga38502ce11e5ec923e0f6476aaa35b45c"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_DMACmd" ref="ga38502ce11e5ec923e0f6476aaa35b45c" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_DMACmd </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the specified I2C DMA requests. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2C DMA transfer. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab2e994c5681eb6ec7c26a03ffe1de060"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_DMALastTransferCmd" ref="gab2e994c5681eb6ec7c26a03ffe1de060" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_DMALastTransferCmd </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies if the next DMA transfer will be the last one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2C DMA last transfer. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga02145a333a56e79557d6ef4ea03fc313"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_DualAddressCmd" ref="ga02145a333a56e79557d6ef4ea03fc313" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_DualAddressCmd </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the specified I2C dual addressing mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2C dual addressing mode. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa570f76bc34e5b0531b29b1a90af1275"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_FastModeDutyCycleConfig" ref="gaa570f76bc34e5b0531b29b1a90af1275" args="(I2C_TypeDef *I2Cx, uint16_t I2C_DutyCycle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_FastModeDutyCycleConfig </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>I2C_DutyCycle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Selects the specified I2C fast mode duty cycle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I2C_DutyCycle,:</em>&nbsp;</td><td>specifies the fast mode duty cycle. This parameter can be one of the following values: </p>
<ul>
<li>I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2 </li>
<li>I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga65c740fc8d7b3b9f15cc432d8699d471"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_GeneralCallCmd" ref="ga65c740fc8d7b3b9f15cc432d8699d471" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_GeneralCallCmd </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the specified I2C general call feature. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2C General call. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga36c522b471588be9779c878222ccb20f"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_GenerateSTART" ref="ga36c522b471588be9779c878222ccb20f" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_GenerateSTART </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates I2Cx communication START condition. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2C START condition generation. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None.</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5c92cb573ca0ae58cc465e5400246561"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_GenerateSTOP" ref="ga5c92cb573ca0ae58cc465e5400246561" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_GenerateSTOP </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates I2Cx communication STOP condition. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2C STOP condition generation. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None.</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15c95d0ed124f029621a2061b1677ee7"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_GetFlagStatus" ref="ga15c95d0ed124f029621a2061b1677ee7" args="(I2C_TypeDef *I2Cx, uint32_t I2C_FLAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FlagStatus I2C_GetFlagStatus </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>I2C_FLAG</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether the specified I2C flag is set or not. </p>
<p>3) Flag-based state monitoring</p>
<p>3) Flag-based state monitoring </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I2C_FLAG,:</em>&nbsp;</td><td>specifies the flag to check. This parameter can be one of the following values: </p>
<ul>
<li>I2C_FLAG_DUALF: Dual flag (Slave mode) </li>
<li>I2C_FLAG_SMBHOST: SMBus host header (Slave mode) </li>
<li>I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode) </li>
<li>I2C_FLAG_GENCALL: General call header flag (Slave mode) </li>
<li>I2C_FLAG_TRA: Transmitter/Receiver flag </li>
<li>I2C_FLAG_BUSY: Bus busy flag </li>
<li>I2C_FLAG_MSL: Master/Slave flag </li>
<li>I2C_FLAG_SMBALERT: SMBus Alert flag </li>
<li>I2C_FLAG_TIMEOUT: Timeout or Tlow error flag </li>
<li>I2C_FLAG_PECERR: PEC error in reception flag </li>
<li>I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode) </li>
<li>I2C_FLAG_AF: Acknowledge failure flag </li>
<li>I2C_FLAG_ARLO: Arbitration lost flag (Master mode) </li>
<li>I2C_FLAG_BERR: Bus error flag </li>
<li>I2C_FLAG_TXE: Data register empty flag (Transmitter) </li>
<li>I2C_FLAG_RXNE: Data register not empty (Receiver) flag </li>
<li>I2C_FLAG_STOPF: Stop detection flag (Slave mode) </li>
<li>I2C_FLAG_ADD10: 10-bit header sent flag (Master mode) </li>
<li>I2C_FLAG_BTF: Byte transfer finished flag </li>
<li>I2C_FLAG_ADDR: Address sent flag (Master mode) “ADSL” Address matched flag (Slave mode)”ENDAD” </li>
<li>I2C_FLAG_SB: Start bit flag (Master mode) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>The</em>&nbsp;</td><td>new state of I2C_FLAG (SET or RESET). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga447771fbbd94a56f3570b9f430a069ba"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_GetITStatus" ref="ga447771fbbd94a56f3570b9f430a069ba" args="(I2C_TypeDef *I2Cx, uint32_t I2C_IT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ITStatus I2C_GetITStatus </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>I2C_IT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether the specified I2C interrupt has occurred or not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I2C_IT,:</em>&nbsp;</td><td>specifies the interrupt source to check. This parameter can be one of the following values: </p>
<ul>
<li>I2C_IT_SMBALERT: SMBus Alert flag </li>
<li>I2C_IT_TIMEOUT: Timeout or Tlow error flag </li>
<li>I2C_IT_PECERR: PEC error in reception flag </li>
<li>I2C_IT_OVR: Overrun/Underrun flag (Slave mode) </li>
<li>I2C_IT_AF: Acknowledge failure flag </li>
<li>I2C_IT_ARLO: Arbitration lost flag (Master mode) </li>
<li>I2C_IT_BERR: Bus error flag </li>
<li>I2C_IT_TXE: Data register empty flag (Transmitter) </li>
<li>I2C_IT_RXNE: Data register not empty (Receiver) flag </li>
<li>I2C_IT_STOPF: Stop detection flag (Slave mode) </li>
<li>I2C_IT_ADD10: 10-bit header sent flag (Master mode) </li>
<li>I2C_IT_BTF: Byte transfer finished flag </li>
<li>I2C_IT_ADDR: Address sent flag (Master mode) “ADSL” Address matched flag (Slave mode)”ENDAD” </li>
<li>I2C_IT_SB: Start bit flag (Master mode) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>The</em>&nbsp;</td><td>new state of I2C_IT (SET or RESET). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga29237aea9b5a3ead33167e1d027e9f1a"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_GetLastEvent" ref="ga29237aea9b5a3ead33167e1d027e9f1a" args="(I2C_TypeDef *I2Cx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2C_GetLastEvent </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the last I2Cx Event. </p>
<p>2) Advanced state monitoring</p>
<p>2) Advanced state monitoring </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>: For detailed description of Events, please refer to section I2C_Events in <a class="el" href="stm32f10x__i2c_8h.html" title="This file contains all the functions prototypes for the I2C firmware library.">stm32f10x_i2c.h</a> file.</dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>The</em>&nbsp;</td><td>last event </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7bf75e7c27c0e1d73e70fc0e1c7cd1dd"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_GetPEC" ref="ga7bf75e7c27c0e1d73e70fc0e1c7cd1dd" args="(I2C_TypeDef *I2Cx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2C_GetPEC </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the PEC value for the specified I2C. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>The</em>&nbsp;</td><td>PEC value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaac29465bca70fbc91c2f922ab67bb88e"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_Init" ref="gaac29465bca70fbc91c2f922ab67bb88e" args="(I2C_TypeDef *I2Cx, I2C_InitTypeDef *I2C_InitStruct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Init </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___init_type_def.html">I2C_InitTypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2C_InitStruct</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the I2Cx peripheral according to the specified parameters in the I2C_InitStruct. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I2C_InitStruct,:</em>&nbsp;</td><td>pointer to a <a class="el" href="struct_i2_c___init_type_def.html" title="I2C Init structure definition.">I2C_InitTypeDef</a> structure that contains the configuration information for the specified I2C peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga58fed146a06cb81d2940604e460de047"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_ITConfig" ref="ga58fed146a06cb81d2940604e460de047" args="(I2C_TypeDef *I2Cx, uint16_t I2C_IT, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_ITConfig </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>I2C_IT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the specified I2C interrupts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I2C_IT,:</em>&nbsp;</td><td>specifies the I2C interrupts sources to be enabled or disabled. This parameter can be any combination of the following values: </p>
<ul>
<li>I2C_IT_BUF: Buffer interrupt mask </li>
<li>I2C_IT_EVT: Event interrupt mask </li>
<li>I2C_IT_ERR: Error interrupt mask </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the specified I2C interrupts. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7be2cc634a613c8e3539137e897a22df"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_OwnAddress2Config" ref="ga7be2cc634a613c8e3539137e897a22df" args="(I2C_TypeDef *I2Cx, uint8_t Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_OwnAddress2Config </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>Address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures the specified I2C own address2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address,:</em>&nbsp;</td><td>specifies the 7bit I2C own address2. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None.</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5d0f939bdd45542502827bf408f24161"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_PECPositionConfig" ref="ga5d0f939bdd45542502827bf408f24161" args="(I2C_TypeDef *I2Cx, uint16_t I2C_PECPosition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_PECPositionConfig </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>I2C_PECPosition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Selects the specified I2C PEC position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I2C_PECPosition,:</em>&nbsp;</td><td>specifies the PEC position. This parameter can be one of the following values: </p>
<ul>
<li>I2C_PECPosition_Next: indicates that the next byte is PEC </li>
<li>I2C_PECPosition_Current: indicates that current byte is PEC </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8021dc796d15f997356b0583d6346805"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_ReadRegister" ref="ga8021dc796d15f997356b0583d6346805" args="(I2C_TypeDef *I2Cx, uint8_t I2C_Register)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t I2C_ReadRegister </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>I2C_Register</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the specified I2C register and returns its value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2C_Register,:</em>&nbsp;</td><td>specifies the register to read. This parameter can be one of the following values: </p>
<ul>
<li>I2C_Register_CR1: CR1 register. </li>
<li>I2C_Register_CR2: CR2 register. </li>
<li>I2C_Register_OAR1: OAR1 register. </li>
<li>I2C_Register_OAR2: OAR2 register. </li>
<li>I2C_Register_DR: DR register. </li>
<li>I2C_Register_SR1: SR1 register. </li>
<li>I2C_Register_SR2: SR2 register. </li>
<li>I2C_Register_CCR: CCR register. </li>
<li>I2C_Register_TRISE: TRISE register. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>The</em>&nbsp;</td><td>value of the read register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeaaa4b6f77f50eb57465148c55d27fb2"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_ReceiveData" ref="gaeaaa4b6f77f50eb57465148c55d27fb2" args="(I2C_TypeDef *I2Cx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2C_ReceiveData </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the most recent received data by the I2Cx peripheral. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>The</em>&nbsp;</td><td>value of the received data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga009fc2a5b2313c36da39ece39a1156a6"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_Send7bitAddress" ref="ga009fc2a5b2313c36da39ece39a1156a6" args="(I2C_TypeDef *I2Cx, uint8_t Address, uint8_t I2C_Direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Send7bitAddress </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>Address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>I2C_Direction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transmits the address byte to select the slave device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address,:</em>&nbsp;</td><td>specifies the slave address which will be transmitted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I2C_Direction,:</em>&nbsp;</td><td>specifies whether the I2C device will be a Transmitter or a Receiver. This parameter can be one of the following values </p>
<ul>
<li>I2C_Direction_Transmitter: Transmitter mode </li>
<li>I2C_Direction_Receiver: Receiver mode </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None.</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7bd9e70b8eafde0dd5eb42b0d95fe1a9"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_SendData" ref="ga7bd9e70b8eafde0dd5eb42b0d95fe1a9" args="(I2C_TypeDef *I2Cx, uint8_t Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_SendData </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a data byte through the I2Cx peripheral. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data,:</em>&nbsp;</td><td>Byte to be transmitted.. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75a810776d9710d2f6d9c5d9e93241c6"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_SMBusAlertConfig" ref="ga75a810776d9710d2f6d9c5d9e93241c6" args="(I2C_TypeDef *I2Cx, uint16_t I2C_SMBusAlert)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_SMBusAlertConfig </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>I2C_SMBusAlert</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drives the SMBusAlert pin high or low for the specified I2C. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>I2C_SMBusAlert,:</em>&nbsp;</td><td>specifies SMBAlert pin level. This parameter can be one of the following values: </p>
<ul>
<li>I2C_SMBusAlert_Low: SMBAlert pin driven low </li>
<li>I2C_SMBusAlert_High: SMBAlert pin driven high </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1289c908aeb882443aba323b459c638b"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_SoftwareResetCmd" ref="ga1289c908aeb882443aba323b459c638b" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_SoftwareResetCmd </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the specified I2C software reset. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2C software reset. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7459feb3b1dfcd3e4f6574002ca7d3bd"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_StretchClockCmd" ref="ga7459feb3b1dfcd3e4f6574002ca7d3bd" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_StretchClockCmd </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the specified I2C Clock stretching. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2Cx Clock stretching. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08582aca6d7d7910cd5cbff0d9def350"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_StructInit" ref="ga08582aca6d7d7910cd5cbff0d9def350" args="(I2C_InitTypeDef *I2C_InitStruct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_StructInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___init_type_def.html">I2C_InitTypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2C_InitStruct</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills each I2C_InitStruct member with its default value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2C_InitStruct,:</em>&nbsp;</td><td>pointer to an <a class="el" href="struct_i2_c___init_type_def.html" title="I2C Init structure definition.">I2C_InitTypeDef</a> structure which will be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa27d1440290fe601e730b6980999afe3"></a><!-- doxytag: member="stm32f10x_i2c.h::I2C_TransmitPEC" ref="gaa27d1440290fe601e730b6980999afe3" args="(I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_TransmitPEC </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionalState&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the specified I2C PEC transfer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>I2Cx,:</em>&nbsp;</td><td>where x can be 1 or 2 to select the I2C peripheral. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewState,:</em>&nbsp;</td><td>new state of the I2C PEC transmission. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Aug 4 2010 16:45:58 for STM32 Peripheral Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
